<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural World Builder - Educational Videos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .main-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #scene-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #fff;
        }
        
        .control-group input, .control-group select, .control-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .control-group input::placeholder, .control-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .btn.secondary {
            background: linear-gradient(45deg, #3742fa, #2f3542);
        }
        
        .btn.secondary:hover {
            box-shadow: 0 5px 15px rgba(55, 66, 250, 0.4);
        }
        
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            z-index: 100;
        }
        
        .caption {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 25px;
            backdrop-filter: blur(5px);
            z-index: 100;
            min-width: 300px;
            text-align: center;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .caption.show {
            opacity: 1;
        }
        
        .templates {
            margin-top: 20px;
        }
        
        .template-btn {
            width: 100%;
            margin: 5px 0;
            text-align: left;
            background: linear-gradient(45deg, #2ed573, #1e90ff);
        }
        
        .template-btn:hover {
            box-shadow: 0 5px 15px rgba(46, 213, 115, 0.4);
        }
        
        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #ee5a24);
            width: 0%;
            transition: width 0.3s ease;
            z-index: 101;
        }
        
        .json-editor {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            resize: vertical;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>üåç World Builder</h2>
            
            <div class="controls">
                <div class="control-group">
                    <label>Ch·ªß ƒë·ªÅ:</label>
                    <select id="topic">
                        <option value="solar-system">H·ªá M·∫∑t Tr·ªùi</option>
                        <option value="cell-structure">C·∫•u tr√∫c T·∫ø b√†o</option>
                        <option value="molecular">C·∫•u tr√∫c Ph√¢n t·ª≠</option>
                        <option value="ecosystem">H·ªá sinh th√°i</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>T·ªëc ƒë·ªô Animation:</label>
                    <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1">
                </div>
                
                <div class="control-group">
                    <label>ƒê·ªô ph·ª©c t·∫°p:</label>
                    <input type="range" id="complexity" min="1" max="10" step="1" value="5">
                </div>
                
                <button class="btn" onclick="generateScene()">üé¨ T·∫°o Scene</button>
                <button class="btn secondary" onclick="playAnimation()">‚ñ∂Ô∏è Ph√°t</button>
                <button class="btn secondary" onclick="pauseAnimation()">‚è∏Ô∏è T·∫°m d·ª´ng</button>
                <button class="btn secondary" onclick="exportScene()">üíæ Xu·∫•t JSON</button>
            </div>
            
            <div class="templates">
                <h3>üìã Templates</h3>
                <button class="btn template-btn" onclick="loadTemplate('planets')">ü™ê H√†nh tinh</button>
                <button class="btn template-btn" onclick="loadTemplate('atoms')">‚öõÔ∏è Nguy√™n t·ª≠</button>
                <button class="btn template-btn" onclick="loadTemplate('dna')">üß¨ DNA</button>
                <button class="btn template-btn" onclick="loadTemplate('forest')">üå≤ R·ª´ng</button>
            </div>
            
            <div class="control-group">
                <label>Scene Definition (JSON):</label>
                <textarea id="scene-json" class="json-editor" placeholder="Nh·∫≠p JSON scene definition..."></textarea>
                <button class="btn" onclick="loadFromJSON()">üì• Load t·ª´ JSON</button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="scene-container"></div>
            
            <div class="overlay">
                <div id="scene-title">üåç Procedural World Builder</div>
                <div id="scene-subtitle">T·∫°o th·∫ø gi·ªõi 3D cho video gi√°o d·ª•c</div>
            </div>
            
            <div class="caption" id="caption"></div>
            
            <div class="stats" id="stats">
                <div>FPS: <span id="fps">60</span></div>
                <div>Objects: <span id="objects">0</span></div>
                <div>Vertices: <span id="vertices">0</span></div>
            </div>
            
            <div class="progress-bar" id="progress"></div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let animationId;
        let currentAnimation = null;
        let sceneObjects = [];
        let isPlaying = false;
        let currentStep = 0;
        let totalSteps = 0;
        let fps = 60;
        let lastTime = performance.now();
        let frameCount = 0;
        
        // Scene templates
        const templates = {
            planets: {
                title: "H·ªá M·∫∑t Tr·ªùi",
                subtitle: "Kh√°m ph√° c√°c h√†nh tinh",
                objects: [
                    { type: "sphere", position: [0, 0, 0], scale: [2, 2, 2], color: "#FDB813", name: "M·∫∑t Tr·ªùi" },
                    { type: "sphere", position: [5, 0, 0], scale: [0.3, 0.3, 0.3], color: "#8C7853", name: "Sao Th·ªßy" },
                    { type: "sphere", position: [7, 0, 0], scale: [0.4, 0.4, 0.4], color: "#FFC649", name: "Sao Kim" },
                    { type: "sphere", position: [9, 0, 0], scale: [0.5, 0.5, 0.5], color: "#6B93D6", name: "Tr√°i ƒê·∫•t" },
                    { type: "sphere", position: [12, 0, 0], scale: [0.4, 0.4, 0.4], color: "#C1440E", name: "Sao H·ªèa" }
                ],
                animations: [
                    { type: "rotation", axis: "y", speed: 0.01 },
                    { type: "orbit", center: [0, 0, 0], radius: 5, speed: 0.02 }
                ],
                captions: [
                    "M·∫∑t Tr·ªùi l√† ng√¥i sao trung t√¢m c·ªßa h·ªá M·∫∑t Tr·ªùi",
                    "C√°c h√†nh tinh quay quanh M·∫∑t Tr·ªùi theo qu·ªπ ƒë·∫°o ellip",
                    "Tr√°i ƒê·∫•t l√† h√†nh tinh th·ª© ba t·ª´ M·∫∑t Tr·ªùi"
                ]
            },
            atoms: {
                title: "C·∫•u tr√∫c Nguy√™n t·ª≠",
                subtitle: "M√¥ h√¨nh nguy√™n t·ª≠ Bohr",
                objects: [
                    { type: "sphere", position: [0, 0, 0], scale: [0.5, 0.5, 0.5], color: "#FF6B6B", name: "H·∫°t nh√¢n" },
                    { type: "sphere", position: [2, 0, 0], scale: [0.2, 0.2, 0.2], color: "#4ECDC4", name: "Electron" },
                    { type: "sphere", position: [0, 2, 0], scale: [0.2, 0.2, 0.2], color: "#4ECDC4", name: "Electron" },
                    { type: "sphere", position: [-2, 0, 0], scale: [0.2, 0.2, 0.2], color: "#4ECDC4", name: "Electron" }
                ],
                animations: [
                    { type: "orbit", center: [0, 0, 0], radius: 2, speed: 0.05 }
                ],
                captions: [
                    "Nguy√™n t·ª≠ bao g·ªìm h·∫°t nh√¢n v√† electron",
                    "Electron chuy·ªÉn ƒë·ªông quanh h·∫°t nh√¢n",
                    "M·ªói l·ªõp electron c√≥ nƒÉng l∆∞·ª£ng kh√°c nhau"
                ]
            },
            dna: {
                title: "C·∫•u tr√∫c DNA",
                subtitle: "Chu·ªói xo·∫Øn k√©p",
                objects: [],
                animations: [
                    { type: "helix", radius: 1, pitch: 0.5, speed: 0.02 }
                ],
                captions: [
                    "DNA c√≥ c·∫•u tr√∫c xo·∫Øn k√©p",
                    "Hai s·ª£i DNA ƒë∆∞·ª£c li√™n k·∫øt b·∫±ng base pairs",
                    "DNA ch·ª©a th√¥ng tin di truy·ªÅn"
                ]
            },
            forest: {
                title: "H·ªá sinh th√°i R·ª´ng",
                subtitle: "ƒêa d·∫°ng sinh h·ªçc",
                objects: [
                    { type: "cylinder", position: [0, 1, 0], scale: [0.2, 2, 0.2], color: "#8B4513", name: "Th√¢n c√¢y" },
                    { type: "sphere", position: [0, 3, 0], scale: [1, 1, 1], color: "#228B22", name: "T√°n l√°" },
                    { type: "cylinder", position: [3, 0.5, 2], scale: [0.15, 1, 0.15], color: "#8B4513", name: "Th√¢n c√¢y" },
                    { type: "sphere", position: [3, 2, 2], scale: [0.8, 0.8, 0.8], color: "#32CD32", name: "T√°n l√°" }
                ],
                animations: [
                    { type: "sway", amplitude: 0.1, speed: 0.01 }
                ],
                captions: [
                    "R·ª´ng l√† h·ªá sinh th√°i ph·ª©c t·∫°p",
                    "C√¢y c·ªëi cung c·∫•p oxy cho sinh v·∫≠t",
                    "ƒêa d·∫°ng sinh h·ªçc r·∫•t quan tr·ªçng"
                ]
            }
        };
        
        // Initialize the application
        function init() {
            setupScene();
            setupControls();
            loadTemplate('planets');
            animate();
        }
        
        function setupScene() {
            const container = document.getElementById('scene-container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Particle system for atmosphere
            createParticleSystem();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function createParticleSystem() {
            const particleCount = 500;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 100;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x88ccff,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        function setupControls() {
            // Manual camera controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    
                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 0.5),
                            toRadians(deltaMove.x * 0.5),
                            0,
                            'XYZ'
                        ));
                    
                    camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                }
                
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Zoom controls
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            });
        }
        
        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }
        
        function generateScene() {
            clearScene();
            
            const topic = document.getElementById('topic').value;
            const complexity = parseInt(document.getElementById('complexity').value);
            
            // Generate procedural content based on topic and complexity
            switch(topic) {
                case 'solar-system':
                    generateSolarSystem(complexity);
                    break;
                case 'cell-structure':
                    generateCellStructure(complexity);
                    break;
                case 'molecular':
                    generateMolecularStructure(complexity);
                    break;
                case 'ecosystem':
                    generateEcosystem(complexity);
                    break;
            }
            
            updateStats();
            showCaption("Scene ƒë∆∞·ª£c t·∫°o v·ªõi ƒë·ªô ph·ª©c t·∫°p " + complexity);
        }
        
        function generateSolarSystem(complexity) {
            const planets = [
                { name: "M·∫∑t Tr·ªùi", distance: 0, size: 2, color: "#FDB813" },
                { name: "Sao Th·ªßy", distance: 5, size: 0.3, color: "#8C7853" },
                { name: "Sao Kim", distance: 7, size: 0.4, color: "#FFC649" },
                { name: "Tr√°i ƒê·∫•t", distance: 9, size: 0.5, color: "#6B93D6" },
                { name: "Sao H·ªèa", distance: 12, size: 0.4, color: "#C1440E" }
            ];
            
            planets.slice(0, Math.min(complexity, planets.length)).forEach((planet, index) => {
                const geometry = new THREE.SphereGeometry(planet.size, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: planet.color });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(planet.distance, 0, 0);
                mesh.userData = { 
                    name: planet.name,
                    distance: planet.distance,
                    rotationSpeed: 0.01 + Math.random() * 0.02
                };
                
                scene.add(mesh);
                sceneObjects.push(mesh);
                
                // Add orbit rings
                if (planet.distance > 0) {
                    const ringGeometry = new THREE.RingGeometry(planet.distance - 0.1, planet.distance + 0.1, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x444444, 
                        transparent: true, 
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    scene.add(ring);
                    sceneObjects.push(ring);
                }
            });
        }
        
        function generateCellStructure(complexity) {
            // Cell membrane
            const membraneGeometry = new THREE.SphereGeometry(5, 32, 32);
            const membraneMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x44aa44, 
                transparent: true, 
                opacity: 0.3,
                wireframe: true
            });
            const membrane = new THREE.Mesh(membraneGeometry, membraneMaterial);
            scene.add(membrane);
            sceneObjects.push(membrane);
            
            // Nucleus
            const nucleusGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const nucleusMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
            scene.add(nucleus);
            sceneObjects.push(nucleus);
            
            // Organelles
            const organelleCount = Math.min(complexity * 2, 20);
            for (let i = 0; i < organelleCount; i++) {
                const size = 0.2 + Math.random() * 0.3;
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5) 
                });
                const organelle = new THREE.Mesh(geometry, material);
                
                // Random position within cell
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 2;
                organelle.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 3,
                    Math.sin(angle) * radius
                );
                
                organelle.userData = { 
                    floatSpeed: 0.005 + Math.random() * 0.01,
                    floatOffset: Math.random() * Math.PI * 2
                };
                
                scene.add(organelle);
                sceneObjects.push(organelle);
            }
        }
        
        function generateMolecularStructure(complexity) {
            // Create molecular bonds and atoms
            const atomCount = Math.min(complexity * 3, 30);
            const bondLength = 1.5;
            
            for (let i = 0; i < atomCount; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(i / atomCount, 0.8, 0.6) 
                });
                const atom = new THREE.Mesh(geometry, material);
                
                // Arrange in a molecular pattern
                const angle = (i / atomCount) * Math.PI * 2;
                const radius = 2 + Math.sin(i * 0.5) * 1;
                atom.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(i * 0.3) * 2,
                    Math.sin(angle) * radius
                );
                
                atom.userData = { 
                    vibrateSpeed: 0.02 + Math.random() * 0.02,
                    vibrateOffset: Math.random() * Math.PI * 2
                };
                
                scene.add(atom);
                sceneObjects.push(atom);
                
                // Add bonds to nearby atoms
                if (i > 0) {
                    const bondGeometry = new THREE.CylinderGeometry(0.05, 0.05, bondLength, 8);
                    const bondMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    const bond = new THREE.Mesh(bondGeometry, bondMaterial);
                    
                    // Position bond between atoms
                    const prevAtom = sceneObjects[sceneObjects.length - 2];
                    const midPoint = new THREE.Vector3().addVectors(atom.position, prevAtom.position).multiplyScalar(0.5);
                    bond.position.copy(midPoint);
                    
                    // Rotate bond to face the other atom
                    bond.lookAt(atom.position);
                    bond.rotateX(Math.PI / 2);
                    
                    scene.add(bond);
                    sceneObjects.push(bond);
                }
            }
        }
        
        function generateEcosystem(complexity) {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x2d5016 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            scene.add(ground);
            sceneObjects.push(ground);
            
            // Trees
            const treeCount = Math.min(complexity * 2, 20);
            for (let i = 0; i < treeCount; i++) {
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                // Leaves
                const leavesGeometry = new THREE.SphereGeometry(1, 16, 16);
                const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                
                // Position randomly
                const x = (Math.random() - 0.5) * 15;
                const z = (Math.random() - 0.5) * 15;
                
                trunk.position.set(x, 0, z);
                leaves.position.set(x, 2, z);
                
                trunk.userData = { 
                    swaySpeed: 0.01 + Math.random() * 0.01,
                    swayOffset: Math.random() * Math.PI * 2
                };
                leaves.userData = trunk.userData;
                
                scene.add(trunk);
                scene.add(leaves);
                sceneObjects.push(trunk, leaves);
            }
        }
        
        function clearScene() {
            sceneObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            sceneObjects = [];
        }
        
        function loadTemplate(templateName) {
            const template = templates[templateName];
            if (!template) return;
            
            clearScene();
            
            // Update UI
            document.getElementById('scene-title').textContent = template.title;
            document.getElementById('scene-subtitle').textContent = template.subtitle;
            
            // Create objects
            template.objects.forEach(objData => {
                let geometry, material, mesh;
                
                switch(objData.type) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                        break;
                    case 'box':
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        break;
                    default:
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                }
                
                material = new THREE.MeshPhongMaterial({ color: objData.color });
                mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(...objData.position);
                mesh.scale.set(...objData.scale);
                mesh.userData = { name: objData.name };
                
                scene.add(mesh);
                sceneObjects.push(mesh);
            });
            
            // Store template data for animations
            currentTemplate = template;
            currentStep = 0;
            totalSteps = template.captions.length;
            
            updateStats();
            showCaption(template.captions[0]);
        }
        
        function playAnimation() {
            if (isPlaying) return;
            
            isPlaying = true;
            currentStep = 0;
            
            // Start caption animation
            if (currentTemplate && currentTemplate.captions.length > 0) {
                animateCaptions();
            }
        }
        
        function animateCaptions() {
            if (!currentTemplate || currentStep >= currentTemplate.captions.length) {
                isPlaying = false;
                return;
            }
            
            showCaption(currentTemplate.captions[currentStep]);
            
            // Update progress
            const progress = ((currentStep + 1) / totalSteps) * 100;
            document.getElementById('progress').style.width = progress + '%';
            
            // Text-to-speech simulation (you can integrate real TTS here)
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(currentTemplate.captions[currentStep]);
                utterance.lang = 'vi-VN';
                utterance.rate = 0.8;
                speechSynthesis.speak(utterance);
            }
            
            currentStep++;
            
            setTimeout(() => {
                if (isPlaying) animateCaptions();
            }, 4000); // 4 seconds per caption
        }
        
        function pauseAnimation() {
            isPlaying = false;
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
        }
        
        function showCaption(text) {
            const caption = document.getElementById('caption');
            caption.textContent = text;
            caption.classList.add('show');
            
            setTimeout(() => {
                caption.classList.remove('show');
            }, 3500);
        }
        
        function exportScene() {
            const sceneData = {
                title: document.getElementById('scene-title').textContent,
                subtitle: document.getElementById('scene-subtitle').textContent,
                objects: sceneObjects.map(obj => ({
                    type: obj.geometry.type,
                    position: [obj.position.x, obj.position.y, obj.position.z],
                    scale: [obj.scale.x, obj.scale.y, obj.scale.z],
                    rotation: [obj.rotation.x, obj.rotation.y, obj.rotation.z],
                    color: obj.material.color.getHexString(),
                    name: obj.userData.name || 'Object'
                })),
                camera: {
                    position: [camera.position.x, camera.position.y, camera.position.z],
                    rotation: [camera.rotation.x, camera.rotation.y, camera.rotation.z]
                },
                settings: {
                    topic: document.getElementById('topic').value,
                    complexity: document.getElementById('complexity').value,
                    speed: document.getElementById('speed').value
                }
            };
            
            document.getElementById('scene-json').value = JSON.stringify(sceneData, null, 2);
            showCaption("Scene ƒë√£ ƒë∆∞·ª£c xu·∫•t th√†nh JSON");
        }
        
        function loadFromJSON() {
            try {
                const jsonData = JSON.parse(document.getElementById('scene-json').value);
                
                clearScene();
                
                // Update UI
                document.getElementById('scene-title').textContent = jsonData.title || 'Custom Scene';
                document.getElementById('scene-subtitle').textContent = jsonData.subtitle || 'Loaded from JSON';
                
                // Create objects from JSON
                jsonData.objects.forEach(objData => {
                    let geometry, material, mesh;
                    
                    // Determine geometry type
                    if (objData.type.includes('Sphere')) {
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                    } else if (objData.type.includes('Cylinder')) {
                        geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                    } else if (objData.type.includes('Box')) {
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                    } else {
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                    }
                    
                    material = new THREE.MeshPhongMaterial({ color: '#' + objData.color });
                    mesh = new THREE.Mesh(geometry, material);
                    
                    mesh.position.set(...objData.position);
                    mesh.scale.set(...objData.scale);
                    mesh.rotation.set(...objData.rotation);
                    mesh.userData = { name: objData.name };
                    
                    scene.add(mesh);
                    sceneObjects.push(mesh);
                });
                
                // Update camera
                if (jsonData.camera) {
                    camera.position.set(...jsonData.camera.position);
                    camera.rotation.set(...jsonData.camera.rotation);
                }
                
                // Update settings
                if (jsonData.settings) {
                    document.getElementById('topic').value = jsonData.settings.topic || 'solar-system';
                    document.getElementById('complexity').value = jsonData.settings.complexity || 5;
                    document.getElementById('speed').value = jsonData.settings.speed || 1;
                }
                
                updateStats();
                showCaption("Scene ƒë√£ ƒë∆∞·ª£c load t·ª´ JSON");
                
            } catch (error) {
                showCaption("L·ªói: JSON kh√¥ng h·ª£p l·ªá");
                console.error('JSON parsing error:', error);
            }
        }
        
        function updateStats() {
            document.getElementById('objects').textContent = sceneObjects.length;
            
            let totalVertices = 0;
            sceneObjects.forEach(obj => {
                if (obj.geometry && obj.geometry.attributes.position) {
                    totalVertices += obj.geometry.attributes.position.count;
                }
            });
            document.getElementById('vertices').textContent = totalVertices;
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Calculate FPS
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            const speed = parseFloat(document.getElementById('speed').value);
            const time = Date.now() * 0.001 * speed;
            
            // Animate objects based on their type and user data
            sceneObjects.forEach(obj => {
                if (obj.userData) {
                    // Rotation animation
                    if (obj.userData.rotationSpeed) {
                        obj.rotation.y += obj.userData.rotationSpeed * speed;
                    }
                    
                    // Floating animation for organelles
                    if (obj.userData.floatSpeed) {
                        obj.position.y += Math.sin(time + obj.userData.floatOffset) * obj.userData.floatSpeed;
                    }
                    
                    // Vibration for molecules
                    if (obj.userData.vibrateSpeed) {
                        const vibration = Math.sin(time * 10 + obj.userData.vibrateOffset) * 0.05;
                        obj.position.x += vibration;
                        obj.position.z += vibration;
                    }
                    
                    // Swaying for trees
                    if (obj.userData.swaySpeed) {
                        const sway = Math.sin(time + obj.userData.swayOffset) * 0.1;
                        obj.rotation.z = sway;
                    }
                }
            });
            
            // Orbital motion for planets
            if (currentTemplate && currentTemplate.title === "H·ªá M·∫∑t Tr·ªùi") {
                sceneObjects.forEach((obj, index) => {
                    if (obj.userData.distance > 0) {
                        const orbitSpeed = 0.02 / Math.sqrt(obj.userData.distance);
                        const angle = time * orbitSpeed;
                        obj.position.x = Math.cos(angle) * obj.userData.distance;
                        obj.position.z = Math.sin(angle) * obj.userData.distance;
                    }
                });
            }
            
            // Camera auto-movement (optional)
            if (isPlaying) {
                camera.position.x = Math.sin(time * 0.1) * 20;
                camera.position.z = Math.cos(time * 0.1) * 20;
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // Sample scene definitions for reference
        const sampleScenes = {
            dnaHelix: {
                title: "C·∫•u tr√∫c DNA",
                subtitle: "Chu·ªói xo·∫Øn k√©p",
                objects: [
                    {
                        type: "sphere",
                        position: [0, 0, 0],
                        scale: [0.2, 0.2, 0.2],
                        color: "ff0000",
                        name: "Base A"
                    },
                    {
                        type: "sphere",
                        position: [1, 0.5, 0],
                        scale: [0.2, 0.2, 0.2],
                        color: "00ff00",
                        name: "Base T"
                    }
                ],
                animations: [
                    {
                        type: "helix",
                        radius: 2,
                        pitch: 1,
                        speed: 0.02
                    }
                ],
                captions: [
                    "DNA c√≥ c·∫•u tr√∫c xo·∫Øn k√©p ƒë∆∞·ª£c t·∫°o th√†nh t·ª´ hai s·ª£i song song",
                    "C√°c base A-T v√† G-C t·∫°o th√†nh c·∫∑p b·ªï sung",
                    "C·∫•u tr√∫c n√†y cho ph√©p DNA t·ª± nh√¢n b·∫£n"
                ]
            },
            
            photosynthesis: {
                title: "Qu√° tr√¨nh Quang h·ª£p",
                subtitle: "Chuy·ªÉn ƒë·ªïi nƒÉng l∆∞·ª£ng √°nh s√°ng",
                objects: [
                    {
                        type: "sphere",
                        position: [-5, 2, 0],
                        scale: [1, 1, 1],
                        color: "ffff00",
                        name: "M·∫∑t tr·ªùi"
                    },
                    {
                        type: "box",
                        position: [0, 0, 0],
                        scale: [2, 1, 0.1],
                        color: "00ff00",
                        name: "L√° c√¢y"
                    }
                ],
                captions: [
                    "C√¢y xanh h·∫•p th·ª• √°nh s√°ng m·∫∑t tr·ªùi",
                    "CO2 v√† H2O ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi th√†nh glucose",
                    "Oxygen ƒë∆∞·ª£c gi·∫£i ph√≥ng nh∆∞ s·∫£n ph·∫©m ph·ª•"
                ]
            }
        };
        
        // Initialize the application when the page loads
        window.addEventListener('load', init);
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    if (isPlaying) pauseAnimation();
                    else playAnimation();
                    break;
                case 'r':
                    generateScene();
                    break;
                case 'e':
                    exportScene();
                    break;
                case '1':
                    loadTemplate('planets');
                    break;
                case '2':
                    loadTemplate('atoms');
                    break;
                case '3':
                    loadTemplate('dna');
                    break;
                case '4':
                    loadTemplate('forest');
                    break;
            }
        });
        
        // Auto-save functionality
        setInterval(() => {
            if (sceneObjects.length > 0) {
                const autoSave = {
                    timestamp: new Date().toISOString(),
                    sceneCount: sceneObjects.length,
                    currentTemplate: currentTemplate ? currentTemplate.title : 'Custom'
                };
                // In a real app, you'd save to localStorage or send to server
                console.log('Auto-save:', autoSave);
            }
        }, 30000); // Auto-save every 30 seconds
        
        // Sample JSON for testing
        const sampleJSON = `{
  "title": "M√¥ h√¨nh Nguy√™n t·ª≠ Hydro",
  "subtitle": "Electron quay quanh proton",
  "objects": [
    {
      "type": "SphereGeometry",
      "position": [0, 0, 0],
      "scale": [0.5, 0.5, 0.5],
      "rotation": [0, 0, 0],
      "color": "ff0000",
      "name": "Proton"
    },
    {
      "type": "SphereGeometry", 
      "position": [2, 0, 0],
      "scale": [0.2, 0.2, 0.2],
      "rotation": [0, 0, 0],
      "color": "0000ff",
      "name": "Electron"
    }
  ],
  "camera": {
    "position": [0, 5, 15],
    "rotation": [0, 0, 0]
  },
  "settings": {
    "topic": "molecular",
    "complexity": "3",
    "speed": "1"
  }
}`;
        
        // Set sample JSON in textarea for demo
        setTimeout(() => {
            document.getElementById('scene-json').value = sampleJSON;
        }, 1000);
    </script>
</body>
</html>
